<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>CuSha</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1><a href="http://farkhor.github.io/CuSha/"><img src="images/CuSha-logo.png"></img></a></h1>
        <p>CuSha is a CUDA-based vertex-centric graph processing framework that uses G-Shards and CW representations.</p>

        <p class="view">View the Project on GitHub: <a href="https://github.com/farkhor/CuSha">farkhor/CuSha</a></p>


        <ul>
          <li><a href="https://github.com/farkhor/CuSha/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/farkhor/CuSha/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/farkhor/CuSha">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        
    
    <h3><a name="about-cusha" class="anchor" href="#about-cusha"><span class="octicon octicon-link"></span></a>About CuSha</h3>    
      <p>
        CuSha is a CUDA-based vertex-centric graph processing framework that uses G-Shards and Concatenated Windows (CW) representations to store graphs inside the GPU global memory. 
        G-Shards and CW consume more space compared to Virtual Warp-Centric (VWC) method that uses Compressed Sparse Row (CSR) format but on the other hand provide better performance due to GPU-friednly representations. 
        For completeness, provided package also includes VWC processing method for GPU and a multi-threaded CPU implementation (that uses CSR as well). CPU implementation utilizes Pthreads.
      </p>
      <p>
      We prepared a paper about CuSha that's accepted in <a href="http://www.hpdc.org/2014/"><em>HPDC'14</em></a>:
      <pre><code>F. Khorasani, K. Vora, R. Gupta, and L.N. Bhuyan
CuSha: Vertex-Centric Graph Processing on GPUs,
23rd International ACM Symposium on High Performance Parallel and Distributed Computing,
13 pages, Vancouver, Canada, June 2014.
</code></pre>
      </p>
        
    <h3><a name="requirements" class="anchor" href="#requirements"><span class="octicon octicon-link"></span></a>Requirements</h3>    
      <p><ul>
        <li>Provided package, as it is, contains multiple source files. 
        As a result, you will need CUDA 5.0 or higher to compile separately and link, alongside a CUDA-enabled device with Compute Capability (CC) 2.0 or higher. 
        For more info, please have a look at <a href="http://on-demand.gputechconf.com/gtc-express/2012/presentations/gpu-object-linking.pdf">these slides</a>.    
        </li><li>For processing with both G-Shards and CW representations, I have used  <em>__syncthreads _or(int)</em> function, which is not supported in architectures before Fermi. 
        Other than that, atomic operations require minimum CCs. 
        Please refer to <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/#atomic-functions">CUDA programming guide</a> for more info. 
        </li><li>CuSha is forward-compatible with warp sizes rather than 32.   
        </li><li>Provided VWC on GPU requires physical warp size to be 32.   
        </li><li>Multi-threaded CPU program requires <em>NVCC</em> to be compiled although with small modifications it can be a pure C/C++ piece of code.   
        </li><li>This package is tested under <b>Ubuntu 12.04</b>. It wouldn't be hard to port it to other Operating Systems.
     </ul></p>    
        
    <h3><a name="usage" class="anchor" href="#usage"><span class="octicon octicon-link"></span></a>Usage</h3>    
     <p>
       Now I assume your CUDA-enabled device meets the requirements and you want to use CuSha. 
       This section tells you how to define your algorithm in CuSha, compile them, and run them. 
       <b>Please note algorithm definition steps for CSR based graph processing (VWC and Multi-threaded CPU) are a bit different but completely independant from CuSha representations.</b>
     </p>
     <h4>Algorithm Definition</h4>
     <p>
       To use CuSha, you need to first specify vertex content and edge content for the graph. 
       For CSR based processing methods, fill up <em>csr-UserStructures.cuh</em>, 
       and for G-Shards and CW fill up <em>cusha-UserStructures.cuh</em> For example, for SSSP algorithm, <em>Vertex</em> and <em>Edge</em> structures are defined like below:
<pre><code>typedef struct Vertex{ unsigned int distance; }Vertex;
typedef struct Edge{ unsigned int weight; }Edge;    
</code></pre>
    </p>
    <p>You can also fill up <em>Vertex_static</em> structure when there are vertex properties remaining intact during graph processing.</p>

    <p>The next step is to define required functions for CSR based processing and CuSha.</p>
    
    <h4>Compile and Link</h4>
    <p>
      I have provided a very straight forward build bash script named <em>sfBuild.sh</em> that compiles files with required flags and links them and outputs the executable.
      Specified architecture (compute capability) in <em>sfBuild.sh</em> is 3.5. You will have to modify it according to your target device.
    </p>
    <p>
    Provided build file does compilation for all the files every time you run it. 
    If you are interested to play with the code, it is definitely better to use <b>Nsight Eclipse Edition</b>. 
    In order to do so, create an empty CUDA C/C++ project (with specified sm architecture and separate compilation) in Nsight. 
    Then right click on the project on <em>Project Explorer</em>, select <em>import</em>-><em>General</em>-><em>File System</em>. 
    Then you have to specify the directory you have downloaded from this website and check <em>entryPoint.cu</em> plus all other 3 folders. 
    After you click on finish, you are ready to build the project for Debug and Release and tune project's settings easier. 
    In addition, when you make a change to only a few source files, Nsight only compiles modifed files, and then links them. Hence you'll experience less waiting periods. 
    </p>
    
    <h4>Run</h4>
    If you run the output executable from last step without any command-line input (or without required parameters), it prints out the usage to the system standard output. 
    That's pretty much what I'm about to write here, except I don't bring it here anymore because you already know how to get what I was going to say ;) . 
    One thing I have to mention is the input file to the executable. An input graph for CuSha (in form of a plain text file) contains edges.
    Each line in the input file corresponds to an edge in the graph and has at least two vertex indices separated by space or tab. 
    The first number specifies the vertex index the tail of the edge corresponds to and the second one shows the vertex index for the head. 
    This convention is found in many publicly available real-world graphs, such as <a href="http://snap.stanford.edu/data/">SNAP</a>'s. 
    Additinal inputs for edges like edge weight or initial vertex content can be supplied with more numbers in each row. 
    Examples can be found in provided templates.
    
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/farkhor">farkhor</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>
